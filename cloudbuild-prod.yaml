steps:
  # Install dependencies (with optimizations)
  - name: "node:20-alpine"
    entrypoint: "sh"
    args:
      - "-c"
      - |
        corepack enable && \
        corepack prepare pnpm@9.15.2 --activate && \
        pnpm install --frozen-lockfile --prefer-offline
    id: "install-deps"

  # Run only critical tests in parallel
  - name: "node:20-alpine"
    entrypoint: "sh"
    args:
      - "-c"
      - |
        corepack enable && \
        corepack prepare pnpm@9.15.2 --activate && \
        pnpm test -- --passWithNoTests --watchAll=false --coverage=false --testPathPatterns="(critical|integration|radar.*bug)" --maxWorkers=2
    waitFor: ["install-deps"]
    id: "run-tests"

  # Check if version changed and create tag if needed (PRODUCTION GATE)
  - name: "node:20-alpine"
    entrypoint: "sh"
    args:
      - "-c"
      - |
        # Install git (needed for version-check script)
        apk add --no-cache git && \
        # Make script executable and run version check
        chmod +x scripts/version-check.sh && \
        # Run version check - this will exit with code 1 if no deploy needed
        if ./scripts/version-check.sh prod; then
          echo "Version check passed - deploy approved"
          # Extract the created tag name for Docker tagging
          LATEST_TAG=$(git tag --list | grep "^prod-" | sort -V | tail -1)
          echo "$LATEST_TAG" > /workspace/version_tag.txt
          echo "Production tag: $LATEST_TAG"
        else
          echo "Version check failed - no deploy needed"
          exit 1
        fi
    waitFor: ["install-deps"]
    id: "version-check"

  # Create the .env file (can run in parallel with tests)
  - name: "gcr.io/cloud-builders/gcloud"
    entrypoint: "bash"
    args:
      - "-c"
      - |
        echo "NEXT_PUBLIC_CIVITAS_API_URL=https://api.civitas.rio" > .env.production && \
        echo "NEXT_PUBLIC_MAPBOX_ACCESS_TOKEN=pk.eyJ1IjoiZXNjcml0b3Jpb2RlZGFkb3MiLCJhIjoiY2t3bWdmcHpjMmJ2cTJucWJ4MGQ1Mm1kbiJ9.4hHJX-1pSevYoBbja7Pq4w" >> .env.production && \
        echo "NEXT_PUBLIC_VISION_AI_URL=http://app.dados.rio/vision-ai" >> .env.production
    waitFor: ["-"]
    id: "create-env"

  # Build the container image with cache optimization
  - name: "gcr.io/cloud-builders/docker"
    entrypoint: "bash"
    args:
      - "-c"
      - |
        VERSION_TAG=$(cat /workspace/version_tag.txt)
        PACKAGE_VERSION=$(node -p "require('./package.json').version")
        docker build \
          --cache-from gcr.io/$PROJECT_ID/civitas:latest \
          -t gcr.io/$PROJECT_ID/civitas:$COMMIT_SHA \
          -t gcr.io/$PROJECT_ID/civitas:latest \
          -t gcr.io/$PROJECT_ID/civitas:$$VERSION_TAG \
          -t gcr.io/$PROJECT_ID/civitas:v$$PACKAGE_VERSION \
          .
    waitFor: ["run-tests", "version-check", "create-env"]

  # Push all images to Container Registry
  - name: "gcr.io/cloud-builders/docker"
    args: ["push", "gcr.io/$PROJECT_ID/civitas:$COMMIT_SHA"]
  - name: "gcr.io/cloud-builders/docker"
    args: ["push", "gcr.io/$PROJECT_ID/civitas:latest"]
  - name: "gcr.io/cloud-builders/docker"
    entrypoint: "bash"
    args:
      - "-c"
      - |
        VERSION_TAG=$(cat /workspace/version_tag.txt)
        PACKAGE_VERSION=$(node -p "require('./package.json').version")
        docker push gcr.io/$PROJECT_ID/civitas:$$VERSION_TAG
        docker push gcr.io/$PROJECT_ID/civitas:v$$PACKAGE_VERSION

  # Save deployment info for rollback
  - name: "gcr.io/cloud-builders/gcloud"
    entrypoint: "bash"
    args:
      - "-c"
      - |
        VERSION_TAG=$(cat /workspace/version_tag.txt)
        PACKAGE_VERSION=$(node -p "require('./package.json').version")
        TIMESTAMP=$(date +%Y-%m-%d\ %H:%M:%S)
        echo "Deployment Info:" > deployment-info.txt && \
        echo "Timestamp: $$TIMESTAMP" >> deployment-info.txt && \
        echo "Commit SHA: $COMMIT_SHA" >> deployment-info.txt && \
        echo "Package Version: $$PACKAGE_VERSION" >> deployment-info.txt && \
        echo "Version Tag: $$VERSION_TAG" >> deployment-info.txt && \
        echo "Simple Version Tag: v$$PACKAGE_VERSION" >> deployment-info.txt && \
        echo "Image Tag: gcr.io/$PROJECT_ID/civitas:$COMMIT_SHA" >> deployment-info.txt && \
        echo "Branch: $BRANCH_NAME" >> deployment-info.txt && \
        gsutil cp deployment-info.txt gs://$PROJECT_ID-deployments/prod/deployment-info-$$VERSION_TAG.txt

  # Kustomize: set the image in the kustomization.yaml file
  - name: "gcr.io/cloud-builders/gke-deploy"
    dir: "k8s/prod"
    entrypoint: "kustomize"
    args:
      - "edit"
      - "set"
      - "image"
      - "gcr.io/project-id/civitas=gcr.io/$PROJECT_ID/civitas:$COMMIT_SHA"

  # Kustomize: apply the kustomization.yaml file
  - name: "gcr.io/cloud-builders/gke-deploy"
    dir: "k8s/prod"
    entrypoint: "kustomize"
    args: ["build", ".", "-o", "prod.yaml"]

  # Deploy the application to the GKE cluster
  - name: "gcr.io/cloud-builders/gke-deploy"
    dir: "k8s/prod"
    args:
      - "run"
      - "--filename=prod.yaml"
      - "--location=us-central1"
      - "--cluster=datario"
      - "--project=datario"

  # Health check and deployment verification
  - name: "gcr.io/cloud-builders/curl"
    entrypoint: "bash"
    args:
      - "-c"
      - |
        echo "Waiting for deployment to be ready..." && \
        sleep 30 && \
        curl -f https://civitas.rio/health || echo "Health check failed, but deployment completed"

images:
  - "gcr.io/$PROJECT_ID/civitas:$COMMIT_SHA"
  - "gcr.io/$PROJECT_ID/civitas:latest"
# Note: Version-specific tags are pushed dynamically based on package.json version

# Store deployment history for rollback
artifacts:
  objects:
    location: "gs://$PROJECT_ID-deployments/prod/"
    paths: ["deployment-info.txt"]

# Only run if version check passed (step succeeded)
options:
  logging: CLOUD_LOGGING_ONLY
